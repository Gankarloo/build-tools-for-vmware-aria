import * as ts from "typescript";

import { PolyglotDescriptor } from "../../../../decorators";
import { getPropertyName } from "../../helpers/node";

/**
 * Contains code related to workflow polyglot logic.
 */
export function buildPolyglotInfo(polyglotInfo: PolyglotDescriptor, decoratorCallExp: ts.CallExpression) {
	const objLiteralNode = decoratorCallExp.arguments[0] as ts.ObjectLiteralExpression;
	if (objLiteralNode) {
		objLiteralNode.properties.forEach((property: ts.PropertyAssignment) => {
			const propName = getPropertyName(property.name);
			switch (propName) {
				case "package":
					polyglotInfo.package = (<ts.StringLiteral>property.initializer).text;
					break;
				case "method":
					polyglotInfo.method = (<ts.StringLiteral>property.initializer).text;
					break;
				default:
					throw new Error(`Polyglot attribute '${propName}' is not suported.`);
			}
		});
	}
}

export function printPolyglotCode(moduleName: string, methodName: string, input: string[], output: string[]): string {
	let result = "";
	result += `//AUTOGENERATED POLYGLOT INVOCATION ---- DON'T TOUCHE THIS SECTION CODE\n`;
	result += `System.log("Starting execution of polyglot decorator")\n`;
	result += `var polyglot_module = System.getModule("${moduleName}");`;
	result += `var polyglot_result = polyglot_module["${methodName}"](${buildPolyglotInputArgs(input)});\n`;
	result += `${buildOutput(output)} = polyglot_result;\n`;
	result += `System.log("Finish execution of polyglot decorator")\n`;
	result += `System.log("Starting execution of action code")\n`;

	return result;
}

export function buildPolyglotInputArgs(input: string[]): string {
	let inputArgs = "";
	{
		for (let i = 0; i < input.length; i += 1) {
			inputArgs += `${input[i]},`;
		}
	}
	return inputArgs.substring(0, inputArgs.length - 1);//Remove the last ','
}

function buildOutput(output: string[]): string {
	if (output == undefined || output.length == 0) {
		throw new Error("Polyglot decorator require an @Out parameter");
	}
	return output[0];
}
